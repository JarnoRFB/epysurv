from dataclasses import dataclass
from typing import Optional, Sequence

import numpy as np
import pandas as pd
import rpy2.robjects.packages as rpackages
from epysurv.simulation.base import BaseSimulation
from epysurv.simulation.utils import add_date_time_index_to_frame, r_list_to_frame
from rpy2 import robjects
from scipy.stats import nbinom, poisson

surveillance = rpackages.importr("surveillance")


@dataclass
class SeasonalNoisePoisson(BaseSimulation):
    r"""Generation of a cyclic model of a Poisson distribution as background data for a simulated time series.

    The mean of the Poisson distribution is modelled as:
    math:: \mu = \exp{(amplitude\sin{(frequency \cdot (t + \phi))} + \alpha + \beta * week_t + K * state)}
    with :math:`\omega = \pi / 52`

    Parameter
    ----------
    amplitude
        amplitude (range of sinus), default = 1.
    alpha
        parameter to move along the y-axis (negative values not allowed) with alpha >= amplitude, default = 1.
    beta
        regression coefficient, default = 0.
    phi
        factor to create seasonal moves (moves the curve along the x-axis), default = 0.
    frequency
        factor to determine the oscillation-frequency, default = 1.
    seed
        a seed for the random number generation.


    References
    ----------
    http://surveillance.r-forge.r-project.org/
    """

    alpha: float = 1.0
    amplitude: float = 1.0
    beta: float = 0.0
    frequency: int = 1
    phi: int = 0
    seed: Optional[int] = None

    def simulate(
        self,
        length: int,
        state_weight: Optional[float] = None,
        state: Optional[Sequence[int]] = None,
    ) -> pd.DataFrame:
        """Simulate outbreaks.

        Parameters
        ----------
        length
            number of weeks to model. Length is ignored if state is given. In this case the length of state
            is used.
        state
            use a state chain to define the status at this time point (outbreak or not). If not given, a Markov chain is
            generated by the programme, default None.
        state_weight
            additional weight for an outbreak which influences the distribution parameter mu, default = None.

        Returns
        -------
        A DataFrame of an endemic time series that contains n weeks where n=``length``.
        Each row in the DataFrame's represents one time steps where each step is equivalent to one calender week.
        It contains a ``mean`` column which is the mean case count according to the sinus based model.
        And finally, it contains a column ``n_cases`` that consists of the generates case counts
        based on the sinus model
        """
        if self.seed:
            base = robjects.packages.importr("base")
            base.set_seed(self.seed)
        simulated = surveillance.sim_seasonalNoise(
            A=self.amplitude,
            alpha=self.alpha,
            beta=self.beta,
            phi=self.phi,
            length=length,
            frequency=self.frequency,
            state=robjects.NULL if state is None else robjects.IntVector(state),
            K=robjects.NULL if state_weight is None else state_weight,
        )

        simulated = r_list_to_frame(simulated, ["mu", "seasonalBackground"])
        simulated = (
            simulated.pipe(add_date_time_index_to_frame)
            .rename(columns={"mu": "mean", "seasonalBackground": "n_cases"})
            .assign(n_outbreak_cases=0)
        )
        return simulated


@dataclass
class SeasonalNoiseNBinom(BaseSimulation):
    r"""A time series simulation that generates case counts based on a negative binomial model.

    The model is described by a mean :math:`\mu`, variance :math:`\phi * \mu`, a linear predictor including trend
    and seasonality determined by Fourier terms. The :math:`\mu` of the model is depended on the current week and
    is defined as follows:

    :math:`\mu(t) = \exp \left\{ \theta + \beta t +
    \sum_{j=1}^{m} \left\{ \gamma_{1} \cos (\frac{2\pi j t}{52})
    + \gamma_{2} \sin (\frac{2\pi j t}{52}) \right\} \right\}`

    where :math:`t` is the current week, :math:`m` the seasonality length. The simulation is then run using
    this :math:`\mu` and the dispersion parameter :math:`psi` to specify the
    negative binomial model we draw case counts from.

    Parameter
    ----------
    beta
        trend parameter that controls the influence of the current week on :math:`\\mu`.
    gamma_1
        seasonality parameter to model the cos of the Fourier term.
    gamma_2
        seasonality parameter to model the sin of the Fourier term.
    phi
        dispersion parameter that regulates the overdispersion compared to the Poisson distribution
        (:math:`\\phi * \\mu`)
    seasonality_length
        models the seasonality on a annual scope. If set to 0, no seasonality, if set to 1 then we model annual
        seasonality, if set to 2 biannual seasonality and so forth.
    theta
        baseline frequency of cases.
    seed
        a seed for the random number generation.


    References
    ----------
    An improved algorithm for outbreak detection in multiple surveillance system
    https://doi.org/10.1002/sim.5595
    """

    beta: float = 0.003
    gamma_1: float = 0.2
    gamma_2: float = -0.4
    phi: float = 1.0
    seasonality_length: int = 1
    seed: Optional[int] = None
    theta: float = 1.5

    def _seasonality(self, week: int):
        """A Fourier-based seasonality term to model the season-depended case counts.

        Parameter
        ---------
        week
            The week to model the season-based case count
        """
        return sum(
            [
                self.gamma_1 * np.cos((2 * np.pi * year * week) / 52)
                + self.gamma_2 * np.sin((2 * np.pi * year * week) / 52)
                for year in range(1, self.seasonality_length + 1)
            ]
        )

    def simulate(self, length: int) -> pd.DataFrame:
        """Simulate outbreaks.

        Parameter
        ---------
        length
            number of weeks to model, default 100.

        Returns
        -------
        A DataFrame of an endemic time series that contains n weeks where n=``length``.
        Each row in the DataFrame's represents one time steps where each step is equivalent to one calender week.
        It contains a ``mean`` column which is the mean case count according to the sinus based model.
        And finally, it contains a column ``n_cases`` that consists of the generates case counts
        based on the sinus model
        """
        if self.seed:
            np.random.seed(self.seed)
        mu_s = [
            np.exp(self.theta + self.beta * week + self._seasonality(week))
            for week in range(length)
        ]
        if self.phi == 1:
            cases = [poisson.rvs(mu, size=1)[0] for mu in mu_s]
        else:
            cases = []
            for mu in mu_s:
                r = np.float(mu / (self.phi - 1))
                p = r / (r + mu)
                cases.append(nbinom.rvs(r, p, size=1)[0])
        return pd.DataFrame({"n_cases": cases, "n_outbreak_cases": [0] * len(cases)})
